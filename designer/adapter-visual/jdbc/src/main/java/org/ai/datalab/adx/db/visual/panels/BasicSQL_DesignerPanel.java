/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package org.ai.datalab.adx.db.visual.panels;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import javax.swing.ComboBoxModel;
import javax.swing.text.JTextComponent;
import org.netbeans.api.options.OptionsDisplayer;
import org.netbeans.api.progress.ProgressHandle;
import org.openide.util.Exceptions;
import org.ai.datalab.adx.db.DB_Adapter;
import org.ai.datalab.adx.db.DB_Processor;
import org.ai.datalab.adx.db.PreparedQuery;
import org.ai.datalab.core.AbstractExecutorProvider;
import org.ai.datalab.core.Data;
import org.ai.datalab.core.adx.misc.MappingHelper;
import org.ai.datalab.core.adx.misc.ValueGroupingStrategy;
import org.ai.datalab.core.executor.ExecutorType;
import org.ai.datalab.core.misc.Type;
import org.ai.datalab.core.misc.TypeUtil;
import org.ai.datalab.core.resource.Resource;
import org.ai.datalab.core.resource.ResourcePool;
import org.ai.datalab.designer.VariableHighlighterListener;
import org.ai.datalab.designer.editor.SimpleEditor;
import org.ai.datalab.adx.db.visual.DbExecutionUnit;
import org.ai.datalab.designer.panels.VisualNodeValidator;
import org.ai.datalab.designer.util.ResourceVisualUtil;
import org.ai.datalab.designer.visual.resource.ResourceStore;
import org.ai.datalab.visual.DataUtil;
import org.ai.datalab.visual.impl.widget.DescriptiveExecutionUnit;

/**
 *
 * @author Mohan Purushothaman
 */
public class BasicSQL_DesignerPanel extends VisualNodeValidator {

    /**
     * Creates new form BasicSQL_DesignerPanel
     */
    private final ExecutorType type;
    private final Data sampleInput;
    private final JTextComponent textArea;

    public BasicSQL_DesignerPanel(ExecutorType type, Data sampleInput) {
        this.type = type;
        this.sampleInput = sampleInput;
        initComponents();
        textArea = SimpleEditor.addVariableEditorPane(editorPanel, sampleInput, new VariableHighlighterListener() {
            @Override
            public void variableHighlighted(String variable) {
//                EventQueue.invokeLater(() -> {
//                     System.out.println(variable + " highlighed");
//                });

            }

            @Override
            public void reset() {
//                 EventQueue.invokeLater(() -> {
//                     System.out.println("resetted");
//                });
            }

        });
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        resourcePools = new javax.swing.JComboBox<>();
        jButton1 = new javax.swing.JButton();
        editorPanel = new javax.swing.JPanel();

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(BasicSQL_DesignerPanel.class, "BasicSQL_DesignerPanel.jLabel1.text")); // NOI18N

        resourcePools.setModel((ComboBoxModel<ResourcePool<Connection>>)ResourceVisualUtil.getResourceComboBox(Connection.class,null));

        org.openide.awt.Mnemonics.setLocalizedText(jButton1, org.openide.util.NbBundle.getMessage(BasicSQL_DesignerPanel.class, "BasicSQL_DesignerPanel.jButton1.text")); // NOI18N
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 99, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(resourcePools, 0, 509, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addComponent(jButton1)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(resourcePools, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton1))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        editorPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        javax.swing.GroupLayout editorPanelLayout = new javax.swing.GroupLayout(editorPanel);
        editorPanel.setLayout(editorPanelLayout);
        editorPanelLayout.setHorizontalGroup(
            editorPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        editorPanelLayout.setVerticalGroup(
            editorPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 427, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(editorPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(editorPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        boolean open = OptionsDisplayer.getDefault().open(ResourceStore.RESOURCE_PANEL_ID, true);
    }//GEN-LAST:event_jButton1ActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel editorPanel;
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JComboBox<ResourcePool<Connection>> resourcePools;
    // End of variables declaration//GEN-END:variables

    @Override
    public DescriptiveExecutionUnit validateConnector(ProgressHandle handle) throws Exception {
        try {
            ResourcePool<Connection> pool = resourcePools.getItemAt(resourcePools.getSelectedIndex());
            String query = textArea.getText();
            if (pool == null) {
                throw new Exception("DB resource not found");
            }
            MappingHelper mapping = executerQuery(pool, query);
            AbstractExecutorProvider provider = getProvider(pool, query, mapping);
            return new DbExecutionUnit("DB " + type, provider, sampleInput);
        } catch (Exception e) {
            Exceptions.printStackTrace(e);
            throw e;
        }
    }

    private AbstractExecutorProvider getProvider(ResourcePool<Connection> pool, String query, MappingHelper mapping) {
        switch (type) {
            case READER:
                return DB_Adapter.createReader(pool, query, mapping,1);
            case PROCESSOR:
                return new DB_Processor(pool, query, mapping);
            case WRITER:
                return new DB_Processor(pool, query, null);
        }
        throw new RuntimeException("undefined type");
    }

    private MappingHelper executerQuery(ResourcePool<Connection> pool, String query) throws Exception {
        MappingHelper mapping = new MappingHelper();

        try (Resource<Connection> r = pool.getResource()) {
            try (Connection c = r.get()) {
                try {
                    c.setAutoCommit(false);
                    PreparedQuery pQuery = new PreparedQuery(query);
                    try (PreparedStatement p = c.prepareStatement(pQuery.getPreparedQuery())) {
                        pQuery.populateParams(p, sampleInput);
                        if (p.execute()) {
                            ResultSet set = p.getResultSet();
                            boolean rowExists = set.next();
                            for (int i = 1; i <= set.getMetaData().getColumnCount(); i++) {
                                String columnName = set.getMetaData().getColumnName(i);
                                Object val = rowExists ? set.getObject(columnName) : null;
                                String name = DataUtil.normalizeFieldKey(columnName, sampleInput);

                                Type detectedType = TypeUtil.detectType(val);

                                mapping.addIdMap(columnName, name, detectedType.getConverter(), ValueGroupingStrategy.SINGLE, val);
                            }

                        } else {
                            String name = DataUtil.normalizeFieldKey("UPDATE_COUNT", sampleInput);
                            mapping.addIdMap("NOT_USED", name, Type.Long.getConverter(), null, p.getUpdateCount());
                        }

                    }

                } finally {
                    c.rollback();
                }

            }
        }
        return mapping;

    }

    @Override
    public String prepareValidation() {
        return "validating SQL query";
    }

    @Override
    public void finishValidation() {

    }
}
